## Secrets (but only really for local development)
The whole area of secrets and authentication/authorisation is complex.

But as I only really intend to use `microk8s` as a local development environment;
I'm going to accept that the default mechanism of storing a secret in unencrypted form
in `etcd` will be fine.

But for production you'd really need to decide on a viable approach:
- Encryption at rest
- Username/Password
- Service Accounts (and bearer tokens)
- OpenID connect tokens

For local development we really only need to accept that our deployed application needs
some form of `secret` or `token` to be able to access other systems (such as services or databases).

So I'm not going to go into configuring kubernetes to be production level secure, as I just want to
develop a bit code and try it in a kubernetes cluster. This make logical sense in terms of
separating the concerns of a developer and the details of how secrets are injected and what those secrets are.

## Kubectl to create a secret

To create a simple secret to use in our application we can just use the following:
```
kubectl create secret generic username-password --from-literal=username=someuser --from-literal=password='SomeSecretPassword'

# Now we can pull that back out as yaml and hold as a manifest if we wanted to.
kubectl get secret username-password  -o yaml

# You can list all the secrets with
kubectl get secrets
# NAME                             TYPE                                  DATA   AGE
# default-token-rscx7              kubernetes.io/service-account-token   3      17d
# sh.helm.release.v1.testrun.v1    helm.sh/release.v1                    1      2d19h
# testrun-boot-chart-token-2b6jp   kubernetes.io/service-account-token   3      2d19h
# username-password                Opaque                                2      38m

# Now to remove the secret you can just delete it
kubectl delete secret username-password
```

For a developer in a local `microk8s` development environment this is fine, for production
**it is a big security hole!**.

### Using the secret
Now we have a named secret available we need to be able to access it from within
and application.

#### Via files
It is possible to make these secrets as files for example:
```
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: username-password
      optional: false # default setting; "mysecret" must exist
```

#### Via environment variables

Here is an example of how the secrets can be made available via Environment Variables:
```
apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
  - name: mycontainer
    image: redis
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: username-password
            key: username
            optional: false
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: username-password
            key: password
            optional: false
  restartPolicy: Never
```

### The secrets configuration
The file [secret.yaml](secret.yaml) is the secrets manifest and is shown below:
```
apiVersion: v1
# This was generated by using this command and then kubectl get secret username-password  -o yaml
# kubectl create secret generic username-password --from-literal=username=someuser --from-literal=password='SomeSecretPassword'
data:
  password: U29tZVNlY3JldFBhc3N3b3Jk
  username: c29tZXVzZXI=
kind: Secret
metadata:
  name: username-password
  namespace: default
type: Opaque
```

This was pulled out via command `kubectl get secret username-password  -o yaml`.

### Summary
From a developer point of view; life with secrets and environment variables is simple.

Basically just (Java snip example):
```
public class HelloController {

	private final static String SECRET_USERNAME_ENV_VAR = "SECRET_USERNAME";
	private final static String SECRET_PASSWORD_ENV_VAR = "SECRET_PASSWORD";
	private final static String TEST_ENV_VAR = "TEST_ENV_VAR";

...
    var envVarValues = List.of(TEST_ENV_VAR, SECRET_USERNAME_ENV_VAR, SECRET_PASSWORD_ENV_VAR)
						.stream()
						.map(System::getenv)
						.collect(Collectors.toList());
    //Now use those environment variables as you will
...
```

So this is nice, just expect some environment variables to be available and leave it to
some devops guys to make sure they are held securely and injected. This way they can cycle the
usernames/passwords in databases, update the `secrets` and bump the pods to restart.

I just modified [my spring-boot manifest](../spring-boot/spring-boot-for-k8s.yml) and
specifically:
```
...
env:
  # Define the environment variable
  - name: TEST_ENV_VAR # Notice that the case is different here
    # from the key name in the ConfigMap.
    valueFrom:
      configMapKeyRef:
        name: spring-boot-map # The ConfigMap this value comes from.
        key: check_value # The key to fetch, this will get mapped into TEST_ENV_VAR.
  - name: SECRET_USERNAME
    valueFrom:
      secretKeyRef:
        name: username-password
        key: username
        optional: true
  - name: SECRET_PASSWORD
    valueFrom:
      secretKeyRef:
        name: username-password
        key: password
        optional: true
...
```

So in many ways injecting secrets via ENVIRONMENT VARIABLES is just as easy as `configMaps`.
You just reference the name of the secret in this case **user-name-password**.
You can decide if this environment variable is **optional** or not, normally something like
a database would probably not be optional.